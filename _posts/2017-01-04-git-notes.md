---
layout: post
title: 稍微高级一点的 Git 学习笔记
category: 开发工具
tags: [ 'git' ]
---

这篇文章里的内容在很多地方都可以查到，写下来的主要目的是总结一下加强记忆。如果能帮到其他人那就再好不过了。

## Git 各种指令的总结归类

想要彻底玩转 Git， 第一个要理解的概念就是 index（有时也称为 stage）和工作目录的区别，这个事情我个人已经分得很清楚了。通俗一点来讲，如果把 Git 比作一款游戏的话，commit 和 index 就是两种不同的存档方式，commit 是我们通常理解的存档，而 index 可以类比成即时存档。通常的存档可以有很多个，而即时存档只有一个，它只保存我们最近的一些改动，每次更新即时存档都会覆盖掉以前的即时存档。Git 的各种指令实际上就是对存档的操作。我们可以把所有的操作分成以下几类：

  1. 添加 commit
  2. 更新 index
  3. 修改已有的 commit
  4. 修改工作目录

Git 里所有的指令，都是以上几种操作的组合。注意在这里我们暂时先不提分支的事情，因为分支不影响我们以上对于操作的分类。那么，究竟每个指令对应哪些操作呢？以下是一个比较完整的总结：
  * `git add/rm`：[2]
  * `git commit`：[1] 
  * `git reset [tree-ish]`：soft 是[3]，mixed 是[2]+[3]，hard 是 [2]+[3]+[4]
  * `git reset [paths]`： [2]
  * `git checkout [tree-ish]`：[2]+[4]
  * `git checkout [paths]`：[4]
  * `git revert`：[1]
  * `git rebase`：[3]
  * `git merge`：[1]

由上面这个列表可以看出，Git 里大多数的指令都还是只进行一类操作的，唯一比较复杂的就是 `git reset`，在下面我也会着重分析。而一些平常看起来比较容易混淆的操作，比如 `git revert` 和 `git reset`，`git rebase` 和 `git merge` 实际上相差的都有很多，如果理解好了是不会出现不知道什么时候该用什么的情况的。

以上的分析并没有考虑进多个分支的情况，但正如我之前提到的，把分支引入进来并不会对上面指令的分类造成任何改变，我想这正是 Git 强大且神奇的地方。当引入分支时，可以理解为又多了一类“切换分支”的操作，而某些指令会在进行原本操作的同时也进行“切换分支”。分支虽然在实际生产用有其绝对的必要性，但对于我们理解 Git 的各种指令会造成一些额外的麻烦，所以我们可以先暂时忘掉分支的事情。

## 处理冲突，避免分叉

通常来说，我们使用 Git 时最怕预见的事情就是各种的 commit 冲突。但事实上，也正是因为会有 commit 冲突我们才有使用 Git 的必要性。我们要做的并不是定下各种规矩避免 commit 冲突，而是应该学会在遇到冲突时如何处理。另外，有一种和 commit 冲突类似的情况叫做“分叉”，分叉和冲突是完全不一样的两回事，并且是需要尽量避免的，这就需要我们在 commit 时遵循一定的规则。

### 如何正确处理冲突

这两句话应该很有用：一切 commit 冲突都发生在添加 commit 这类操作时；一切 commit 冲突都是因为 commit 时出现了两个不一样的 base。在 Git 里，每一次 commit 都可以理解为一个补丁，而一个补丁要想正确工作，我们需要知道两点：第一是这个补丁是基于什么的，第二是这个补丁具体更改了什么。比如说一次 commit 声明它基于 A，进行了一系列的操作 B，那通过 A 和 B 就可以计算出新的文件长什么样子。而冲突的原因往往出在 A 上，要么 A 根本不存在，要么在 A 的基础上已经有了另外一系列操作 C。如果 A 根本不存在，这时候分叉就会发生，这时候，最重要的事情并非去处理冲突，而是要知道你们团队中有人干了坏事，找到他，教育他才是最重要的。而如果是第二种情况就比较好办，因为我们可以基于 A，B 和 C 计算出新的文件长什么样子，这个过程 Git 通常会帮助我们完成（因为它很聪明）。举例来说，A 里面有一个文件 a.js，C 在 A 的基础上增加了 c.js，B 在 A 的基础上增加了 b.js，那三方合并的结果就是就是包含 a.js，b.js 和 c.js 三个文件的 commit 。在少数情况下，会出现 Git 不能帮我们处理的情况，比如 B 也增加了一个 c.js 但内容和 C 里面的 c.js 完全不一样，这时候就需要人为解决冲突，比如我们可以通过重命名文件的方式来解决。值得一提的是对于文本文件， Git 或者人去解决冲突都不难，但对于二进制文件可能这两种方式都不适用，这也正是 Git 不适合作为二进制文件版本控制的原因。

### 如何正确避免分叉

简单来说就一句话，不要修改别人也看得见的 commit 。在上一节我们说过，分叉是由 A 不存在造成的，但为什么 A 会不存在呢？唯一的原因就是别人悄无声息地把 A 修改过了。这个陈述的逆否命题就是，如果没有人把 A 修改过，那分叉就不会发生。这也正是团队合作使用 Git 的黄金法则。通常来说，修改已有的 commit 都是一些比较高级的操作，而可以通过修改解决的事都可以通过一次新的 commit 来解决。修改 commit 的确有一些好处，但是它所带来的好处并不能弥补分叉所造成的麻烦。

### 如果分叉真的发生了

如果团队里的新人没有遵循黄金法则，导致分叉真的发生了，此时整个团队应该怎么办呢？首先要做的当然是暂停所有的 commit ，让公共仓库保持在一个稳定的状态。如果新人还没有把对公共 commit 的修改上传，团队应该要求新人使用 `git reset` 讲他本地的仓库重置到修改公共 commit 之前的状态，这里因为没有用 `--hard` 选项所以新人的工作都可以得到保留。如果新人已经把对公共 commit 的修改上传，团队应该先弄清楚有多少人在自己本地接受了这次公共 commit 的修改，这些人都应当使用 `git reset` 讲本地仓库重置到接受这次修改公共 commit 的状态，然后再重新 commit。这里的策略是宁可麻烦大多数人也不接受公共 commit 的修改。

## Reset

在这么多命令里，最复杂的一个就是 `git reset` 了。取决于后面跟的是文件还是提交/分支，它的含义完全不一样，而对于提交/分支的操作，又有三种不同的模式。

### `git reset [paths]`

从语义上看，这个命令的含义是讲指定的文件重置到之前的某一个状态，默认是重置到上一个 commit 时这个文件的状态，也可以使用 `git reset [tree-ish] [paths]` 的形式讲文件重置到任何提交时的状态。这种重置操作的对象是 index 而非工作目录，也就是说不管我们怎么折腾，这个文件的内容都不会改变的，改变的是 staged changes。

### `git reset [tree-ish]`

这是最复杂的一个命令，最主要是因为它有3种模式供我们选择。这3种模式共同的作用就是将当前 commit 回滚到以前的某一个 commit，所有这中间的 commit 都会被丢弃。如果我们称回滚之前的 commit 是 A，在 A 的基础上进行了一系列操作 B， 回滚后的 commit 是 C 的话，那根据模式不同，对 B 会有不同的处理方式。在 `--soft` 和 `--mixed` 模式下，B 都会得到保留，不同的是 index 会不会更改。如果使用 `--soft` 模式，index 不更改，所有改变都会被 stage；如果使用 `--mixed` 模式，index 会被更改，所有改变不会被 stage。在 `--hard` 模式下，B 会被抛弃，整个代码仓库像穿越一样回到了 C 的状态，任何 C 到 B 之间的操作都被丢弃了。

## 最佳实践

并不打算将文章写成一个教程，介绍每一个指令的作用。着重说一下 `git reset` 也只是因为它太复杂容易忘。最后说一下我心里的最佳实践吧。当然，关于使用 Git 的最佳实践网上一抓一大把，这里的内容虽然大多是重复的，但至少是自己思考后的总结，结论和别人的一样也算有收获。

  1. 精简代码仓库，IDE 配置文件，图片资源等是否加入仓库要仔细思考，具体情况具体分析，写好 .gitignore，可以使用网上提供的；
  2. commit 说明信息性要强；
  3. 重要 commit 打好 tag，使用 annotated tag；
  4. 团队合作时，使用 git flow 模型
  5. 对于开发时间长的 feature，如果是自己一个人开发，定期使用 rebase 合并其他人的代码；
  6. 多人合作某一个 branch 时，每个人再以此为基础单独开一个 branch，定期合并。总之避免多人共同往一个 branch 提交；
  7. 一个人用的 branch，回滚操作变动不大时使用 reset，变动大时使用 revert；
  8. 修改 commit 说明之类的事情使用 `git commit --amend`；
  9. 多人合作的 branch 回滚操作使用 revert；
  10. branch 用完了该删就删，保持中央代码仓库相对精简。